package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/nakamasato/kubernetes-training/doc"
	yaml "gopkg.in/yaml.v3"
)

func main() {

	f, err := os.Open("readme.yml")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	d := yaml.NewDecoder(f)

	var m map[string][]Version

	if err := d.Decode(&m); err != nil {
		log.Fatal(err)
	}

	generateReadme(m["versions"], "README.md")

	updateVersionInReadme(m["versions"], "contents/README.md")
}

type Version struct {
	Name     string `yaml:"name"`
	Version  string `yaml:"version"`
	RepoUrl  string `yaml:"repoUrl"`
	Category string `yaml:"category"`
	ToDo     bool   `yaml:"todo"`
	Dir string `yaml:"dir"`
}

func (v Version) getReleaseUrl() string {
	if v.Version == "" {
		return v.RepoUrl
	} else if v.Version == "latest" {
		return v.RepoUrl + "/releases"
	} else {
		return v.RepoUrl + "/releases/tag/" + v.Version
	}
}

func (v Version) getToDoString() string {
	if v.ToDo {
		return "(ToDo)"
	} else {
		return ""
	}
}

func generateReadme(versions []Version, filename string) {
	book := doc.NewMarkDown()
	book.WriteTitle("Kubernetes Training", doc.LevelTitle).
		WriteLines(2)

	book.WriteList(fmt.Sprintf("Read on Website: %s", book.GetLink("https://www.nakamasato.com/kubernetes-training", "https://www.nakamasato.com/kubernetes-training")))
	book.WriteList(
		fmt.Sprintf(
			"Read on GitHub: %s (All files were moved to `contents` in %s",
			book.GetLink("contents", "contents"),
			book.GetLink("#105", "https://github.com/nakamasato/kubernetes-training/pull/105"),
		),
	)
	book.WriteList("README.md is generated by `readme.go`")

	book.WriteTitle("Versions", doc.LevelSection)
	for _, version := range versions {
		fmt.Printf("name: %s, version: %s\n", version.Name, version.Version)
		book.WriteList(
			fmt.Sprintf(
				"%s: %s%s",
				version.Name,
				book.GetLink(version.Version, version.getReleaseUrl()),
				version.getToDoString(),
			),
		)
	}

	book.WriteTitle("Cloud Native Trail Map", doc.LevelSection)
	book.WriteList(book.GetLink("https://github.com/cncf/trailmap", "https://github.com/cncf/trailmap"))
	book.WriteList(book.GetLink("https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/", "https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/"))

	book.WriteWordLine(fmt.Sprintf("!%s", book.GetLink("", "https://github.com/cncf/trailmap/blob/master/CNCF_TrailMap_latest.png?raw=true")))

	err := book.Export(filename)
	if err != nil {
		log.Fatal(err)
	}
}

func updateVersionInReadme(versions []Version, filename string) {
	input, err := os.ReadFile(filename)
	if err != nil {
		log.Fatalln(err)
	}

	lines := strings.Split(string(input), "\n")

	for _, version := range versions {
		for i, line := range lines {
			if strings.Contains(line, "Contents") { // not update Contents
				break
			}
			if strings.Contains(line, fmt.Sprintf("1. %s:", version.Name)) {
				lines[i] = fmt.Sprintf(
					"1. %s: [%s](%s)%s",
					version.Name,
					version.Version,
					version.getReleaseUrl(),
					version.getToDoString(),
				)
				break
			}
		}
	}
	output := strings.Join(lines, "\n")
	err = os.WriteFile(filename, []byte(output), 0644)
	if err != nil {
		log.Fatalln(err)
	}
}
